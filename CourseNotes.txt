NOTES ON ANGULAR COURSE
=============================
1.5
Install Angular:
	Make sure to have node installed (and npm)
	To upgrade node version (mac os):
		sudo npm cache clean -f
		sudo npm install -g n
		sudo n stable
Create an Angular project
	ng new name-of-the-project
	cd name-of-the-project
	ng server
1.6
 app>app.component.ts => The TypeScript of the component. Notice the selector section, which is linked with the parent root in the index.html file (app-root)
 app>app.component.html => The template of the component
 index.html => The html file that is actually rendered
1.7
    Installing bootstrap in project:
        npm install --save  bootstrap@3
        Then add the css library in angular.json file (under style section, before the 'src/styles.css' file which is the custom for the project)
2.13
    main.tx First file to be executed in a project. It glues all the modules
    It starts the modules with "bootstrapModule" (previously defined in the import), which connects with the module.ts of your component. This module.ts of your component, connects with the specify ts file of the component itself.
2.15
    creating a component from scratch
2.16
    angular modules (and module files) bundles components
2.18
    Use ng generate component NAME (or ng g c NAME) to generate your own component with the comnmand line (cli)
2.19
    It is required to have always a template for a component, always!
    However, you can use it external (templateURL) or inline (template)
    If using inline, you can use ` (tics) to use multiline. Otherwise, ' for single lines
2.20
    As with templates, for styling the component, you can also use external file (styleUrls , notice this takes an array) or styles (using ` if you need multiple lines). It seems that the css is exclusively for that component, is not inherited in the children
2.21
    Selectors are like css selectors, therefore you can use [] (attributre) or . (class). Id does not work
            selector: 'app-root' ====> <app-root></app-root>
            selector: '[app-root]' ====> <div app-root></app-root>
            selector: '.app-root' ======> <div class='app-root'></div>
2.22
    Data binding can be seen as communication between the code (TS) and the view, and the other way around, from the view towards the code (event binding), or both ways (dual bindings)
        String Interpolation: {{serverName}}
        Property bindings:
                <button [disabled]="allowNewServer">Add</button>
                <p [innerText]="serverName"></p>
                N.B.: You can see the properties you can bind with console.log(element), as well events
        React to events (event binding):
            <button  (click)='onCreateServer()'>Add New Server</button>
            <button  (click)='propertyName="new value"' >Add New Server</button>
            <input  (ihput)='onSomething($event)' > $event contains the data
        Two way data inding (combined property and event binding):
            IN ORDER TO USE TWO_WAY_BINDING (ngModel) you need to import FormsModule!
            <input type="text" class="form-control" [(ngModel)]='myProperty'>
            myProperty will change with a change in input. But also, if somewhere else the myProperty value changes, it will also be reflected in this input control.
2.33
    Directives: Instructions in the DOM
        A component is a directive with template
        But is also possible to have directive without template
            <p appTurnGreen> This will make the paragraph into gree</p>
        Built in directives:
            - Structural directive (*), modifies the structure of the dom by adding/removing the item
                *ngIf:
                Trick to use else (beside use opposite if condition):
                    <p *ngIf='conditioIsTrue;else elseShowBlock'>Show this on IF</p>
                    <ng-template #elseShowBlock>
                        <p>Show this on else</p>
                    </ng-template>
                *ngFor: Repeats the element where is inserted (regardless of whether you use the name in the list or not)
                    <app-server *ngFor="let server of serverList"></app-server>

            - Attribute Directives: Don't modify the DOM by adding or removing elements, but rather modifying the element on which are applied
                ngStyle: Applies styles;
                    <p [ngStyle]="{'background-color': getColor()}"> </p>
                ngClass: Add class
                    <p  [ngStyle]="{'background-color': getColor()}"
                        [ngClass]="{online:isOnline(),offline:!isOnline()}"></p>
4.57
    To debut in the browser, look for the TypeScript file under the sources/webpack/. folder
    Install augury as a chrome extension to debut
5.61
    Property and Event binding on HTML elements
    Property and Event binding on diretives
    Property and Event binding on custom properties and events
    CUSTOM PROPERTY BINDING
        Use to communicate from PARENT TO CHILDREN
        Use Input decorator (do not forget to import) to expose a property to the outside
        Then, this property can be binded to a variable from other component
            CHILD COMPONENT (ts)
            import { ... Input } from '@angular/core';
            <====== MAKE SURE TO IMPORT

            [...]

            export class ParentComponent implements OnInit {
                @Input('HERE_THE_ALIAS') element: { type: string, name: string, content: string};
                <====== NOTICE THE @Input decorator
            }
            PARENT COMPONENT (HTML)
            <app-server-element
                *ngFor="let serverElement of serverElements"
                [ALIAS]="serverElement"> <======== HERE THE ASSIGNMENT
            </app-server-element>
    CUSTOM EVENT BINDING
        Use to communicate from CHILDREN TO PARENT
        We need to create a new event in the child component, and emmit it with an argument.
        Later, in the father, we catch that event and assign it to a proper method, using the argument emmited.

            CHILD COMPONENT
                TypeScript
                    // Make sure to import EventEmitter and Output
                    import { ... EventEmitter, Output } from '@angular/core';

                    []...
                    export class CockpitComponent implements OnInit {
                        // Create event, assign alias and specify argument that will be passed
                      @Output('HERE_THE_EVENT_ALIAS') newChildEvent = new EventEmitter<{serverName: string, serverContent: string}>();
                      // Use a method to trigger te emmision of the event

                      property_1;
                      property_2;

                      onSomethingHappendInChildComponent() {
                        //Emmit the event and properties
                        this.newChildEvent.emit({serverName: this.property_1, serverContent: this.property_2});
                      }
                    }

                HTML
                    <button (click)="onSomethingHappendInChildComponent()">Emmit New Event</button>

            PARENT COMPONENT
                HTML
                    <child-app (HERE_THE_EVENT_ALIAS)="parent_method($event)"></child-app>

                TypeScript
                    parent_method(serverData: {serverName: string, serverContent: string}) {
                            DO_SOMETHING_HERE
                    })

5.68 Encapsulation
    By default, the css only applies to the component. This is because it uses encapsulation.
    This encapsulation is done by appending to each HTML element of component an specific name, and modifying the CSS to only applies to those new components (shadowing).

    However, this behavior can be changed in the component definition:

    import { [...] ViewEncapsulation } from '@angular/core';

    @Component({
        [...]
        encapsulation: ViewEncapsulation.Emulated // None, Native
    })

    - None will remove the shadowing

5.69 Local Reference
    ONLY TO BE USED IN THE TEMPLATE: Allows to have a 'copy' of the HTML element (any) in the template and pass or use this full HTML element in the template. It can be used as a way to get a value from an input

        <input type="text" class="form-control" #serverNameElement>
        <button class="btn btn-primary" (click)="onAddServer(serverNameInput.value)">Add Server</button>
        // Notice the '#serverNameElement' and the serverNameElement.value
5.70 Access to DOM from TS
    It is possible to access the DOM from the ts file with the @ViewChild decorator.
    By adding a reference name into the HTML file, we can use that reference in the TS file. This will import the HTML element into the TS file, and it is possible to access the properties in the TS.
    DO NOT MODIFIED THE DOM DIRECTLY THROUGH THIS REFERENCE, USE OTHER ANGULAR METHODS.
    HTML file
        <input type="text" class="form-control" #ANY_NAME_HERE>
    TypeScript file
        import { ... ViewChild,ElementRef } from '@angular/core';
        [...]

        export class CockpitComponent implements OnInit {
          @ViewChild('ANY_NAME_HERE') serverHTMLElementContentInput:ElementRef;

          onAddServer(serverName) {
            var serverElementContent = this.serverHTMLElementContentInput.nativeElement.value;
            [...]
          }
        }

    It is possible to access a child component (first one) or all the children elements

    import { ... ViewChildren } from '@angular/core';
    import {CockpitComponent} from './cockpit/cockpit.component'

    export class AppComponent {
      @ViewChildren(CockpitComponent) cockpitElement;

       onServerAdded(serverData: {serverName: string, serverContent: string}) {
         console.log(this.cockpitElement._results[0].serverHTMLElementContentInput.nativeElement.value);
         console.log(this.cockpitElement._results[1].serverHTMLElementContentInput.nativeElement.value);
         console.log(this.cockpitElement._results[2].serverHTMLElementContentInput.nativeElement.value);

      }
    }

5.71 Use <ng-content></ng-content> to indicate a  placeholder in a child component. In this placeholder, angular will inject the text passed inside the HTML tags of hte component. The text inside will be "projected" into the view of the child component.

    <child-component>THIS IS ANY CONTENT</child-component>

    child-component.html
        <p> BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA  </p>
        <ng-content></ng-content>
        <p> BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA BLA  </p>

5.72 Lifecycle
    There is quite a bit of hooks that will be triggered during changes, events, constructions, deletions of the angular application: https://angular.io/guide/lifecycle-hooks:
        - ngOnChanges()
        - ngOnInit()
        - ngDoCheck()
        - ngAfterContentInit()
        - ngAfterContentChecked()
        - ngAfterViewInit()
        - ngAfterViewChecked()
        - ngOnDestroy()

5.73 It is also possible to access the ng-content similto to ViewChild, but with ViewContent
    // PARENT ELEMENT HTML
    <child-element>
       <p #ANY_TAG_NAME></p>
    </child-element>

    //CHILD ELEMENT TS
        @ContentChild('ANY_TAG_NAME') contentHTML;

    anyMethod(){
        console.log(this.contentHTML.nativeElement.textContent);
    }

22.295 DEPLOYMENT
    Just run ' ng build --prod' (it turns on AOT by default for prod (ahead of time))
    So, it will be the same as ng build --prod --aot
    The end product will be compiled into hte dist/SolutionName folder

30.397 ANGULAR 6: WHAT'S NEW
    [DONE, nothing to written]

32.414 TYPESCRIPT
    TYPES: string, number, boolean, Array<TYPE>, any, void and your own custom classes
    CLASSES:
        class car {
            name: string;
            private speed: number;
            constructor(speed: number)
            {
                this.speed = speed || 0;
            }
            accelerate():void{
                this.speed++;
            }
            stati numberOfWheels(): number {
            return 4;
            }
        }

        let car = new Car(5);
        car.accelerate();
        Car.numberOfWheels(); // Calling the static method from the class itself
    INTERFACES
        interface User {
            username: string;
            age?: number; // Optional property, does no need to be implemented
            accelerate(speed:number):void;
        }

        let newUser:User = {
            username: 'huertaj';
            accelerate: function(speed:number){
                /...
            }
        }
    MODULES
        Declaring a class to be used outside the file
        export class ClassName {
            // ...
        }
        If you don't use export (modularity), the class wont be able to be used outside that file

7.83 DIRECTIVES
    Attribute Directives: Sit on element and only affect that element
    Structural Directives: Sit on element but changes the DOM by adding/removing elements on it
    A DIRECTIVE DOES NOT HAVE A TEMPLATE!!
    CUSTOM DIRECTIVE

    import { Directive,ElementRef,OnInit } from '@angular/core';
    @Directive({selector:'[appBasicHighlight]'})
    export class BasicHighlightDirective implements OnInit {
        constructor(private elementRef:ElementRef) {}
        ngOnInit(){this.elementRef.nativeElement.style.backgroundColor = 'green';}
    }
    // DO NOT FORGET TO ADD IN THE APP.MODULE.TS
    ng c directive DIRECTIVE_NAME
    // USE BETTER RENDERER TO MODIFY THE DOM
      ngOnInit()
        {
            this.renderer.addClass(this.elRef.nativeElement,'betterHighlight');
        }

    //USE HOSTBINDING FOR BIND A VARIABLE TO A PROPERTY OF THE HOST ELEMENT
    @HostBinding('style.backgroundColor') myVariable: string = 'yellow';
    Any change in myVariable will be applied directly to the style.backgroundColor of the host element
    This solution is similar to the Renderer2, nothing good, nothing bad

7.91 PASSING PROPERTIES TO DIRECTIVES

  @Input() defaultColor: string = 'purple';
  @Input() highlightColor: string = 'cyan';
<div appBetterHighlight [defaultColor]="'red'" [highlightColor]="'pink'">THIS IS A NEW DIRECTIVE</div>



7.84 CONSTRUCTOR TIP
    constructor(private elementRef:ElementRef) {}
    constructor(public elementRef:ElementRef) {}
        This will create a public/private property called elementRef.

7.89 HOSTLISTENER
    // USE A HOSTLISTENER IN DIRECTIVES TO LISTEN TO EVENTS ON THE ELEMENT AND REACT
      @HostListener('mouseenter') mouseover(eventData: Event){
        this.renderer.addClass(this.elRef.nativeElement,'betterHighlight');
        }
7.91 TRICK: Assigning values to properties
    <div appBetterHighlight [defaultColor]="'red'" highlightColor="pink">THIS IS A NEW DIRECTIVE</div>
    Notice you can assign a value to a property withouth single quotes "pink", as long as the property name has no [] signs
    Notice the difference between the assignment of defaultColor ahd highlightColor

7.93 BUILDIN STRUCTURAL DIRECTIVES
    @Input() set appUnless(condition: boolean) {
    Use a setter (instead of property) to create a property that is executed everytime the value of the property changes.So, that means, we assigne the property to  method and this method is executed when the value of the property (assigned externally) changes

    constructor(private templateRef: TemplateRef<any>, private viewContainerRef: ViewContainerRef) { }
    Inject this values to access a template (ng-template) and where to inject or modify the code

    <div *appUnless="false">DISPLAY WHEN FALSE</div>
    <ng-template [appUnless]="false"><div>DISPLAY WHEN FALSE</div></ng-template>

    !!!!!!!!!!!! READ ABOUT TemplateRef vs ViewContainerRef !!!!!!!!
7.94 ngSwitch
       <div *ngFor="let evenNumber of evenNumbers">
       <div [ngSwitch]="evenNumber">
            <p *ngSwitchCase="2">Two</p>
            <p *ngSwitchCase="4">Four</p>
            <p *ngSwitchDefault>Other</p>
       </div> 